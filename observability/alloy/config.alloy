// ----------- Loki sink -----------
loki.write "default" {
	endpoint {
		url = "http://loki:3100/loki/api/v1/push"
	}
}

// ----------- Caddy access logs (from caddy log file) -----------
loki.process "caddy_access" {
	forward_to = [loki.relabel.drop_filename_caddy.receiver]

	// Parse top-level JSON from Caddy access logs
	stage.json {
		expressions = {
			duration = "duration",
			level    = "level",
			logger   = "logger",
			msg      = "msg",
			request  = "request",
			size     = "size",
			status   = "status",
			ts       = "ts",
		}
	}

	// Parse request sub-object
	stage.json {
		source      = "request"
		expressions = {
			method    = "method",
			remote_ip = "remote_ip",
			uri       = "uri",
		}
	}

	// GeoIP enrichment
	stage.geoip {
		db      = "/usr/share/GeoIP/GeoLite2-City.mmdb"
		source  = "remote_ip"
		db_type = "city"
	}

	// Build a compact JSON line with just the necessary fields
	stage.template {
		source   = "packed"
		template = `{{ toJson (dict
            "ts"                       .ts
            "method"                   .method
            "uri"                      .uri
            "remote_ip"                .remote_ip
            "status"                   .status
            "size"                     .size
            "duration"                 .duration
            "geoip_country_name"       .geoip_country_name
            "geoip_city_name"          .geoip_city_name
            "geoip_location_latitude"  .geoip_location_latitude
            "geoip_location_longitude" .geoip_location_longitude
            "msg"                      .msg
        ) }}`
	}

	// Replace the log line with that compact JSON
	stage.output {
		source = "packed"
	}

	stage.timestamp {
		source = "ts"
		format = "Unix"
	}
}

// Drop 'filename' label to keep streams lean
loki.relabel "drop_filename_caddy" {
	forward_to = [loki.write.default.receiver]

	rule {
		action = "labeldrop"
		regex  = "filename"
	}
}

loki.source.file "caddy_access" {
	targets = [{
		__path__ = "/var/log/caddy/access.log",
		host     = sys.env("DOMAIN"),
		job      = "caddy_access",
	}]
	forward_to    = [loki.process.caddy_access.receiver]
	tail_from_end = true
}

// ----------- Docker application logs (from containers stdout) -----------
discovery.docker "docker_logs" {
	host             = "unix:///var/run/docker.sock"
	refresh_interval = "5s"
}

// Map docker meta -> labels
discovery.relabel "docker_logs" {
	targets = []

	rule {
		source_labels = ["__meta_docker_container_log_path"]
		target_label  = "__path__"
	}

	rule {
		source_labels = ["__meta_docker_container_label_app"]
		target_label  = "app"
	}

	rule {
		source_labels = ["__meta_docker_container_label_logfmt"]
		target_label  = "logfmt"
	}

	rule {
		source_labels = ["__meta_docker_container_label_logs_scrape"]
		target_label  = "logs_scrape"
	}

	rule {
		target_label = "job"
		replacement  = "docker_logs"
	}
}

// Tail docker container logs and send to pipeline
loki.source.docker "docker_logs" {
	host             = "unix:///var/run/docker.sock"
	targets          = discovery.docker.docker_logs.targets
	relabel_rules    = discovery.relabel.docker_logs.rules
	refresh_interval = "5s"
	forward_to       = [loki.process.docker_logs.receiver]
}

loki.process "docker_logs" {
	forward_to = [loki.relabel.docker_cleanup.receiver]

	// Drop logs from containers with logs_scrape=false
	stage.match {
		selector = "{logs_scrape=\"false\"}"

		stage.drop {
			expression = ".*"
		}
	}

	stage.labels {
		values = {host = sys.env("DOMAIN")}
	}

	// Parse docker JSON wrapper
	stage.docker { }

	// Plain-text apps
	stage.match {
		selector = "{app=~\"fail2ban|geoipupdate|portainer\"}"

		stage.template {
			source   = "packed"
			template = `{"msg":{{ if .log }}{{ toJson .log }}{{ else }}{{ toJson .Entry }}{{ end }}}`
		}

		stage.output {
			source = "packed"
		}
	}

	// Drop Caddy access lines from stdout to avoid duplicates
	stage.match {
		selector = "{app=\"caddy\"}"

		stage.drop {
			expression = "\"logger\":\"http\\.log\\.access\""
		}
	}

	// Caddy (stdout, non-access, JSON)
	stage.match {
		selector = "{app=\"caddy\"}"

		stage.json {
			expressions = {level = "level", logger = "logger", msg = "msg", ts = "ts"}
		}

		stage.labels {
			values = {level = null}
		}

		stage.template {
			source   = "packed"
			template = `{"msg":{{ toJson .msg }}{{ if .logger }},"logger":{{ toJson .logger }}{{ end }}}`
		}

		stage.output {
			source = "packed"
		}

		stage.timestamp {
			source = "ts"
			format = "Unix"
		}
	}

	// Grafana
	stage.match {
		selector = "{app=\"grafana\"}"

		stage.logfmt {
			mapping = {
				t      = "t",
				level  = "level",
				logger = "logger",
				msg    = "msg",
				error  = "error",
				query  = "query",
			}
		}

		stage.labels {
			values = {level = null}
		}

		stage.template {
			source   = "packed"
			template = `{"logger":{{ toJson .logger }},"msg":{{ toJson .msg }}{{ if .error }},"error":{{ toJson .error }}{{ end }}{{ if .query }},"query":{{ toJson .query }}{{ end }}}`
		}

		stage.output {
			source = "packed"
		}

		stage.timestamp {
			source = "t"
			format = "RFC3339Nano"
		}
	}

	// Alloy
	stage.match {
		selector = "{app=\"alloy\"}"

		// Only try to parse lines that look like Alloy logfmt
		stage.regex {
			expression = "^ts=[^ ]+ level=[^ ]+ msg="
		}

		stage.logfmt {
			mapping = {ts = "ts", level = "level", msg = "msg", component_id = "component_id", error = "error", node_id = "node_id"}
		}

		stage.labels {
			values = {level = null}
		}

		stage.template {
			source   = "packed"
			template = `{"msg":{{ toJson .msg }}{{ if .node_id }},"node_id":{{ toJson .node_id }}{{ end }}{{ if .component_id }},"component_id":{{ toJson .component_id }}{{ end }}{{ if .error }},"error":{{ toJson .error }}{{ end }}}`
		}

		stage.output {
			source = "packed"
		}

		stage.timestamp {
			source = "ts"
			format = "RFC3339Nano"
		}
	}

	// Prometheus
	stage.match {
		selector = "{app=\"prometheus\"}"

		stage.logfmt {
			mapping = {time = "time", level = "level", msg = "msg"}
		}

		stage.labels {
			values = {level = null}
		}

		stage.template {
			source   = "packed"
			template = `{{ toJson (dict
                "msg"    .msg
            ) }}`
		}

		stage.output {
			source = "packed"
		}

		stage.timestamp {
			source = "time"
			format = "RFC3339Nano"
		}
	}

	// Watchtower
	stage.match {
		selector = "{app=\"watchtower\"}"

		stage.regex {
			expression = "time=\"(?P<time>[^\"]+)\"\\s+level=(?P<level>\\w+)\\s+msg=\"(?P<msg>[^\"]+)\"\\s+Failed=(?P<failed>\\d+)\\s+Scanned=(?P<scanned>\\d+)\\s+Updated=(?P<updated>\\d+)\\s+notify=(?P<notify>\\w+)"
		}

		stage.timestamp {
			source = "time"
			format = "RFC3339Nano"
		}

		stage.labels {
			values = {level = null}
		}

		stage.template {
			source   = "packed"
			template = `{"msg":{{ toJson .msg }},"level":{{ toJson .level }},"Failed":{{ .failed }},"Scanned":{{ .scanned }},"Updated":{{ .updated }},"notify":{{ toJson .notify }}}`
		}

		stage.output {
			source = "packed"
		}
	}

	// All other JSON apps (e.g. spring boot apps)
	stage.match {
		selector = "{app!~\"^(caddy|grafana|prometheus|alloy|fail2ban|geoipupdate|portainer|watchtower)$\"}"

		stage.json {
			expressions = {level = "level", logger = "logger_name", msg = "message", ts = "[\"@timestamp\"]", stack_trace = "stack_trace"}
		}

		// Fallbacks if apps use different ts keys
		stage.json {
			expressions = {ts = "timestamp"}
		}

		stage.json {
			expressions = {ts = "time"}
		}

		stage.json {
			expressions = {ts = "ts"}
		}

		stage.labels {
			values = {level = null}
		}

		stage.template {
			source   = "packed"
			template = `{"msg":{{ toJson .msg }},"logger":{{ toJson .logger }}{{ if .stack_trace }},"stack_trace":{{ toJson .stack_trace }}{{ end }}}`
		}

		stage.output {
			source = "packed"
		}

		stage.timestamp {
			source = "ts"
			format = "RFC3339Nano"
		}
	}
}

loki.relabel "docker_cleanup" {
	forward_to = [loki.write.default.receiver]

	rule {
		action = "labeldrop"
		regex  = "logs_scrape"
	}
}
