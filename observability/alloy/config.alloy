discovery.relabel "caddy_access" {
	targets = [{
		__address__ = "localhost",
		__path__    = "/var/log/caddy/access.log",
		host        = sys.env("DOMAIN"),
		job         = "caddy_access",
	}]

	rule {
		regex  = "filename"
		action = "labeldrop"
	}
}

local.file_match "caddy_access" {
	path_targets = discovery.relabel.caddy_access.output
}

loki.process "caddy_access" {
	forward_to = [loki.relabel.drop_filename_caddy.receiver]

	stage.json {
		expressions = {
			duration = "duration",
			level    = "level",
			logger   = "logger",
			msg      = "msg",
			request  = "request",
			size     = "size",
			status   = "status",
			ts       = "ts",
		}
	}

	stage.json {
		expressions = {
			method    = "method",
			remote_ip = "remote_ip",
			uri       = "uri",
		}
		source = "request"
	}

	stage.geoip {
		db      = "/usr/share/GeoIP/GeoLite2-City.mmdb"
		source  = "remote_ip"
		db_type = "city"
	}

	stage.labels {
		values = {
			geoip_country_name = null,
			geoip_city_name    = null,
		}
	}

	stage.timestamp {
		source = "ts"
		format = "Unix"
	}
}

loki.relabel "drop_filename_caddy" {
	forward_to = [loki.write.default.receiver]

	rule {
		action = "labeldrop"
		regex  = "filename"
	}
}

loki.source.file "caddy_access" {
	targets    = local.file_match.caddy_access.targets
	forward_to = [loki.process.caddy_access.receiver]
}

discovery.docker "docker_logs" {
	host             = "unix:///var/run/docker.sock"
	refresh_interval = "5s"

	filter {
		name   = "label"
		values = ["loki=true"]
	}
}

loki.process "docker_logs" {
	forward_to = [loki.write.default.receiver]

	stage.labels {
		values = {
			job  = "docker_logs",
			host = sys.env("DOMAIN"),
		}
	}

	stage.docker { }

	stage.match {
		selector = "{app=\"caddy\"}"

		stage.drop {
			expression = "\"logger\":\"http\\.log\\.access\""
		}
	}

	stage.match {
		selector = "{app=\"caddy\"}"

		stage.json {
			expressions = {
				level  = "level",
				logger = "logger",
				msg    = "msg",
				ts     = "ts",
			}
		}

		stage.labels {
			values = {
				level  = null,
				logger = null,
			}
		}

		stage.output {
			source = "msg"
		}

		stage.timestamp {
			source = "ts"
			format = "Unix"
		}
	}

	stage.match {
		selector = "{logfmt=\"json\", app!=\"caddy\"}"

		stage.json {
			expressions = {
				level  = "level",
				logger = "logger_name",
				msg    = "message",
				ts     = "[\"@timestamp\"]",
			}
		}

		stage.labels {
			values = {
				level  = null,
				logger = null,
			}
		}

		stage.output {
			source = "msg"
		}

		stage.timestamp {
			source = "ts"
			format = "RFC3339Nano"
		}
	}
}

discovery.relabel "docker_logs" {
	targets = []

	rule {
		source_labels = ["__meta_docker_container_log_path"]
		target_label  = "__path__"
	}

	rule {
		source_labels = ["__meta_docker_container_label_app"]
		target_label  = "app"
	}

	rule {
		source_labels = ["__meta_docker_container_label_logfmt"]
		target_label  = "logfmt"
	}
}

loki.source.docker "docker_logs" {
	host             = "unix:///var/run/docker.sock"
	targets          = discovery.docker.docker_logs.targets
	forward_to       = [loki.process.docker_logs.receiver]
	relabel_rules    = discovery.relabel.docker_logs.rules
	refresh_interval = "5s"
}

loki.write "default" {
	endpoint {
		url = "http://loki:3100/loki/api/v1/push"
	}
	external_labels = {}
}
