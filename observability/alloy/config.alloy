// ----------- Loki sink -----------
loki.write "default" {
	endpoint {
		url = "http://loki:3100/loki/api/v1/push"
	}
}

// ----------- Caddy access logs (from caddy log file) -----------
loki.process "caddy_access" {
	forward_to = [loki.relabel.drop_filename_caddy.receiver]

	// Parse top-level JSON from Caddy access logs
	stage.json {
		expressions = {
			duration = "duration",
			level    = "level",
			logger   = "logger",
			msg      = "msg",
			request  = "request",
			size     = "size",
			status   = "status",
			ts       = "ts",
		}
	}

	// Parse request sub-object
	stage.json {
		source      = "request"
		expressions = {
			method    = "method",
			remote_ip = "remote_ip",
			uri       = "uri",
		}
	}

	// GeoIP enrichment
	stage.geoip {
		db      = "/usr/share/GeoIP/GeoLite2-City.mmdb"
		source  = "remote_ip"
		db_type = "city"
	}

	// Build a compact JSON line with just the necessary fields
	stage.template {
		source   = "packed"
		template = `{{ toJson (dict
            "ts"                       .ts
            "method"                   .method
            "uri"                      .uri
            "remote_ip"                .remote_ip
            "status"                   .status
            "size"                     .size
            "duration"                 .duration
            "geoip_country_name"       .geoip_country_name
            "geoip_city_name"          .geoip_city_name
            "geoip_location_latitude"  .geoip_location_latitude
            "geoip_location_longitude" .geoip_location_longitude
            "msg"                      .msg
        ) }}`
	}

	// Replace the log line with that compact JSON
	stage.output {
		source = "packed"
	}

	stage.timestamp {
		source = "ts"
		format = "Unix"
	}
}

// Drop 'filename' label to keep streams lean
loki.relabel "drop_filename_caddy" {
	forward_to = [loki.write.default.receiver]

	rule {
		action = "labeldrop"
		regex  = "filename"
	}
}

loki.source.file "caddy_access" {
	targets = [{
		__path__ = "/var/log/caddy/access.log",
		host     = sys.env("DOMAIN"),
		job      = "caddy_access",
	}]
	forward_to    = [loki.process.caddy_access.receiver]
	tail_from_end = true
}

// ----------- Docker application logs (from containers stdout) -----------
discovery.docker "docker_logs" {
	host             = "unix:///var/run/docker.sock"
	refresh_interval = "5s"
}

// Map docker meta -> labels
discovery.relabel "docker_logs" {
	targets = []

	rule {
		source_labels = ["__meta_docker_container_log_path"]
		target_label  = "__path__"
	}

	rule {
		source_labels = ["__meta_docker_container_label_app"]
		target_label  = "app"
	}

	rule {
		source_labels = ["__meta_docker_container_label_logfmt"]
		target_label  = "logfmt"
	}

	rule {
		source_labels = ["__meta_docker_container_label_logs_scrape"]
		target_label  = "logs_scrape"
	}

	rule {
		target_label = "job"
		replacement  = "docker_logs"
	}
}

// Tail docker container logs and send to pipeline
loki.source.docker "docker_logs" {
	host             = "unix:///var/run/docker.sock"
	targets          = discovery.docker.docker_logs.targets
	relabel_rules    = discovery.relabel.docker_logs.rules
	refresh_interval = "5s"
	forward_to       = [loki.process.docker_logs.receiver]
}

loki.process "docker_logs" {
	forward_to = [loki.relabel.docker_cleanup.receiver]

	// Drop logs from containers with logs_scrape=false
	stage.match {
		selector = "{logs_scrape=\"false\"}"

		stage.drop {
			expression = ".*"
		}
	}

	stage.labels {
		values = {host = sys.env("DOMAIN")}
	}

	// Parse docker JSON wrapper
	stage.docker { }

	// Plain-text apps
	stage.match {
		selector = "{app=~\"fail2ban|geoipupdate|portainer\"}"

		stage.template {
			source   = "packed"
			template = `{"msg":{{ if .log }}{{ toJson .log }}{{ else }}{{ toJson .Entry }}{{ end }}}`
		}

		stage.output {
			source = "packed"
		}
	}

	// Drop Caddy access lines from stdout to avoid duplicates
	stage.match {
		selector = "{app=\"caddy\"}"

		stage.drop {
			expression = "\"logger\":\"http\\.log\\.access\""
		}
	}

	// Caddy (stdout, non-access, JSON)
	stage.match {
		selector = "{app=\"caddy\"}"

		stage.json {
			expressions = {level = "level", logger = "logger", msg = "msg", ts = "ts"}
		}

		stage.labels {
			values = {level = null}
		}

		stage.template {
			source   = "packed"
			template = `{"msg":{{ toJson .msg }}{{ if .logger }},"logger":{{ toJson .logger }}{{ end }}}`
		}

		stage.output {
			source = "packed"
		}

		stage.timestamp {
			source = "ts"
			format = "Unix"
		}
	}

	// Grafana
	stage.match {
		selector = "{app=\"grafana\"}"

		stage.logfmt {
			mapping = {
				t      = "t",
				level  = "level",
				logger = "logger",
				msg    = "msg",
				error  = "error",
				query  = "query",
			}
		}

		stage.labels {
			values = {level = null}
		}

		stage.template {
			source   = "packed"
			template = `{"logger":{{ toJson .logger }},"msg":{{ toJson .msg }}{{ if .error }},"error":{{ toJson .error }}{{ end }}{{ if .query }},"query":{{ toJson .query }}{{ end }}}`
		}

		stage.output {
			source = "packed"
		}

		stage.timestamp {
			source = "t"
			format = "RFC3339Nano"
		}
	}

	// Alloy
	stage.match {
		selector = "{app=\"alloy\"}"

		// Only try to parse lines that look like Alloy logfmt
		stage.regex {
			expression = "^ts=[^ ]+ level=[^ ]+ msg="
		}

		stage.logfmt {
			mapping = {ts = "ts", level = "level", msg = "msg", component_id = "component_id", error = "error", node_id = "node_id"}
		}

		stage.labels {
			values = {level = null}
		}

		stage.template {
			source   = "packed"
			template = `{"msg":{{ toJson .msg }}{{ if .node_id }},"node_id":{{ toJson .node_id }}{{ end }}{{ if .component_id }},"component_id":{{ toJson .component_id }}{{ end }}{{ if .error }},"error":{{ toJson .error }}{{ end }}}`
		}

		stage.output {
			source = "packed"
		}

		stage.timestamp {
			source = "ts"
			format = "RFC3339Nano"
		}
	}

	// Prometheus
	stage.match {
		selector = "{app=\"prometheus\"}"

		stage.logfmt {
			mapping = {time = "time", level = "level", msg = "msg"}
		}

		stage.labels {
			values = {level = null}
		}

		stage.template {
			source   = "packed"
			template = `{{ toJson (dict
                "msg"    .msg
            ) }}`
		}

		stage.output {
			source = "packed"
		}

		stage.timestamp {
			source = "time"
			format = "RFC3339Nano"
		}
	}

	// Watchtower
	stage.match {
		selector = "{app=\"watchtower\"}"

		stage.json {
			expressions = {time = "time", level = "level", msg = "msg", Failed = "Failed", Scanned = "Scanned", Updated = "Updated", notify = "notify"}
		}

		stage.timestamp {
			source = "time"
			format = "RFC3339Nano"
		}

		stage.labels {
			values = {level = null}
		}

		stage.template {
			source   = "packed"
			template = `{"msg":{{ toJson .msg }}{{ if .Failed }},"Failed":{{ toJson .Failed }}{{ end }}{{ if .Scanned }},"Scanned":{{ toJson .Scanned }}{{ end }}{{ if .Updated }},"Updated":{{ toJson .Updated }}{{ end }}{{ if .notify }},"notify":{{ toJson .notify }}{{ end }}}`
		}

		stage.output {
			source = "packed"
		}
	}

	// node-exporter
	stage.match {
		selector = "{app=\"node-exporter\"}"

		stage.logfmt {
			mapping = {time = "time", level = "level", msg = "msg"}
		}

		stage.labels {
			values = {level = null}
		}

		stage.template {
			source   = "packed"
			template = `{{ toJson (dict
              "msg"    .msg
            ) }}`
		}

		stage.output {
			source = "packed"
		}

		stage.timestamp {
			source = "time"
			format = "RFC3339Nano"
		}
	}

	// cAdvisor
	stage.match {
		selector = "{app=\"cadvisor\"}"

		stage.regex {
			expression = "^(?P<level>[IWEF])\\d{4}\\s+\\d{2}:\\d{2}:\\d{2}\\.\\d{6}\\s+\\d+\\s+(?P<file>[^\\s:]+):\\d+\\]\\s+(?P<msg>.*)$"
		}

		stage.template {
			source   = "severity"
			template = `{{ default .level (index (dict "I" "INFO" "W" "WARN" "E" "ERROR" "F" "ERROR") .level) }}`
		}

		stage.labels {
			values = {level = "severity"}
		}

		stage.template {
			source   = "packed"
			template = `{{ toJson (dict "msg" .msg "file" .file) }}`
		}

		stage.output {
			source = "packed"
		}
	}

	// matrix conduit
	stage.match {
		selector = "{app=\"conduit\"}"

		// Strip ANSI color codes
		stage.replace {
			expression = "\\x1b\\[[0-9;]*[A-Za-z]"
			replace    = ""
		}

		// Parse (timestamp optional)
		stage.regex {
			expression = "^(?:(?P<ts>\\S+)\\s+)?(?P<level>[A-Z]+)\\s+(?:(?P<logger>[^\\s:]+):\\s+)?(?P<msg>.*)$"
		}

		// Promote level to a Loki label IF it exists
		stage.labels {
			values = { level = "level" }
		}

		// Only pack/output if parsing succeeded (level label exists)
		stage.match {
			selector = "{app=\"conduit\", level!=\"\"}"

			stage.template {
			source   = "packed"
			template = `{"msg":{{ toJson .msg }},"logger":{{ toJson .logger }},"level":{{ toJson .level }}}`
			}

			stage.output { source = "packed" }
		}
	}

	// All other JSON apps (e.g. spring boot apps)
	stage.match {
		selector = "{app!~\"^(caddy|grafana|prometheus|alloy|fail2ban|geoipupdate|portainer|watchtower|node-exporter|cadvisor|conduit)$\"}"

		stage.json {
			expressions = {level = "level", logger = "logger_name", msg = "message", ts = "[\"@timestamp\"]", stack_trace = "stack_trace"}
		}

		// Fallbacks if apps use different ts keys
		stage.json {
			expressions = {ts = "timestamp"}
		}

		stage.json {
			expressions = {ts = "time"}
		}

		stage.json {
			expressions = {ts = "ts"}
		}

		stage.labels {
			values = {level = null}
		}

		stage.template {
			source   = "packed"
			template = `{"msg":{{ toJson .msg }},"logger":{{ toJson .logger }}{{ if .stack_trace }},"stack_trace":{{ toJson .stack_trace }}{{ end }}}`
		}

		stage.output {
			source = "packed"
		}

		stage.timestamp {
			source = "ts"
			format = "RFC3339Nano"
		}
	}
}

loki.relabel "docker_cleanup" {
	forward_to = [loki.write.default.receiver]

	rule {
		action = "labeldrop"
		regex  = "logs_scrape"
	}
}
